/*******************************************************************************
* Copyright (c) 2017 IBM Corp.
*
* This program and the accompanying materials are made available under the
* terms of the Eclipse Public License 2.0 which accompanies this distribution
* and is available at http://eclipse.org/legal/epl-2.0 or the Apache License, 
* Version 2.0 which accompanies this distribution and is available at 
* https://www.apache.org/licenses/LICENSE-2.0.
* 
* This Source Code may also be made available under the following Secondary
* Licenses when the conditions for such availability set forth in the 
* Eclipse Public License, v. 2.0 are satisfied: GNU General Public License,
* version 2 with the GNU Classpath Exception [1] and GNU General Public License,
* version 2 with the OpenJDK Assembly Exception [2].
* 
* [1] https://www.gnu.org/software/classpath/license.html
* [2] http://openjdk.java.net/legal/assembly-exception.html
*
* SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception
*******************************************************************************/

package net.openj9.test;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.io.File;

//This class will parse log files generated by jit for the purpose
//of testing whether or not intrinsic functions are being replaced
//under the desired conditions

public class LogParser {	
	static String intrinsicsGenExpr = "INTRINSICS: inlined.";
	static String intrinsicsNotGenExpr = "INTRINSICS: not inlined.";
	
	static String methodCallerPackage = "net/openj9/test/";
	
	static String encoding = "Cp1047";
	
	String outputFile, inputFile;
	
	PrintWriter pw;
	
	private boolean activated = false;
	
	public void activate()
	{
		activated = true;
	}
	
	public void deactivate()
	{
		activated = false;
	}
	
	public boolean isActivated()
	{
		return activated;
	}
	
	public LogParser(String outputFile) throws IOException
	{
		File opf = new File(outputFile);
				
		if (!opf.exists())
		{
			opf.createNewFile();
		}
		
		if (opf.exists() && !(opf.canWrite()))
		{
			throw new IOException();
		}

		this.outputFile = outputFile;
		
		pw = new PrintWriter(new FileWriter(outputFile), true);
	}
	
	public void closeWriter()
	{
		pw.close();
	}
	
	public static boolean filterMethodCaller(String temp)
	{
		String filter = "Method caller: " + methodCallerPackage;
		
		if (temp.indexOf(filter) >= 0)
			return true;
		else
			return false;
	}
	
	public static void parseLogFile(String inputFile, String outputFile) throws IOException
	{
		File ipf = new File(inputFile);
		File opf = new File(outputFile);
		
		if (!(ipf.exists()) || !(ipf.canRead()))
		{
			throw new IOException();
		}
		if (opf.exists() && !(opf.canWrite()))
		{
			throw new IOException();
		}
		
		InputStreamReader isr = new InputStreamReader(new FileInputStream(inputFile));
		BufferedReader br = new BufferedReader(isr);
		
		PrintWriter pw = new PrintWriter(new FileWriter(outputFile));
		
		String temp = null;
		temp = br.readLine();
		
		String tempFuncName;
		
		String newCaller = null;
		String oldCaller = null;
		
		while (temp != null)
		{
			tempFuncName = getFuncName(temp);
			if (tempFuncName != null)
			{
				if (filterMethodCaller(temp))
				{
					newCaller = getMethodCallerFuncName(temp);
					
					if (!newCaller.equals(oldCaller))
					{
						pw.println("@" + newCaller);
						oldCaller = newCaller;
					}
					
					if (isGenerated(temp))
					{
						pw.println(tempFuncName);
					}
					else if (isNotGenerated(temp))
					{
						pw.println ("!" + tempFuncName);
					}
				}
			}
			temp = br.readLine();
		}
		
		br.close();
		pw.close();
	}
	
	public static boolean compareLogFiles(String leftFile, String rightFile) throws IOException
	{
		File lf = new File(leftFile);
		File rf = new File(rightFile);
		
		if (!(lf.exists()) || !(lf.canRead()))
		{
			throw new IOException();
		}
		if (!(rf.exists()) || !(rf.canRead()))
		{
			throw new IOException();
		}
		
		InputStreamReader isr = new InputStreamReader(new FileInputStream(leftFile));
		BufferedReader br = new BufferedReader(isr);
		
		InputStreamReader isr2 = new InputStreamReader(new FileInputStream(rightFile));
		BufferedReader br2 = new BufferedReader(isr2);
		
		String lTemp = null;
		lTemp = br.readLine();
		
		String rTemp = null;
		rTemp = br2.readLine();
		
		int lineCount = 0;
		
		while (lTemp != null || rTemp != null)
		{
			if (lTemp == null && rTemp == null)
			{
				// both files ended together
				br.close();
				br2.close();
				return true;
			}
			else if (lTemp == null || rTemp == null)
			{
				System.out.println ("One of the files ended on line " + lineCount);
				br.close();
				br2.close();
				return false;
			}
			else if (!(lTemp.equals(rTemp)))
			{
				System.out.println ("Difference on line " + lineCount + ": ");
				System.out.println (lTemp);
				System.out.println (rTemp);
				br.close();
				br2.close();
				return false;
			}
			
			lTemp = br.readLine();
			rTemp = br2.readLine();
			
			lineCount++;
		}
		
		br.close();
		br2.close();
		return true;
	}
	
	public void addExpected(String funcName)
	{
		//if (isActivated())
			pw.println(funcName);
	}
	
	public void addCallerName(String callerName)
	{
		//if (isActivated())
		pw.println("@" + callerName);
	}
	
	public void addNotExpected(String funcName)
	{
		//if (isActivated())
		pw.println("!" + funcName);
	}
	
	private static boolean isGenerated(String line)
	{
		if (line.indexOf(intrinsicsGenExpr) >= 0)
		{
			return true;
		}
		return false;
	}
	
	private static boolean isNotGenerated(String line)
	{
		if (line.indexOf(intrinsicsNotGenExpr) >= 0)
		{
			return true;
		}
		return false;
	}
	
	private static String getMethodCallerFuncName(String line)
	{
		String temp;
		if (isGenerated(line) || isNotGenerated(line))
		{			
			String methodCaller = "Method caller: ";
			int mcIndex = line.indexOf("Method caller: ");
			temp = line.substring(mcIndex+methodCaller.length());
			
			int slnIndex = temp.indexOf("Source line");
			temp = temp.substring(0, slnIndex);
			
			int nameLastIndex = temp.indexOf('(');
			int nameFirstIndex = temp.lastIndexOf('/', nameLastIndex);
			
			String funcName = temp.substring(nameFirstIndex+1, nameLastIndex);
			return funcName;
		}
		else
			return null;
	}

	private static String getFuncName(String line)
	{
		String temp;
		if (isGenerated(line) || isNotGenerated(line))
		{
			String methodSignature = "Method signature: ";
			int msIndex = line.indexOf(methodSignature);
			temp = line.substring(msIndex+methodSignature.length());
			
			int mcIndex = temp.indexOf("Method caller: ");
			temp = temp.substring(0, mcIndex);
			
			int nameLastIndex = temp.indexOf('(');
			int nameFirstIndex = temp.lastIndexOf('/', nameLastIndex);
			
			if (nameFirstIndex+1 > temp.length()-1)
				System.out.println (temp);
			String funcName=null;
			try
			{
				funcName = temp.substring(nameFirstIndex+1, nameLastIndex);
			}
			catch (StringIndexOutOfBoundsException e)
			{
				System.out.println ("caught");
				System.out.println (temp);
			}
			return funcName;
		}
		else
			return null;
	}
}
